import numpy as np
from stp import *
from collections import Counter

# Calculate the number of possible states: 2^n
num_states = pow(2, len(Genes))

# -----------------------------
# Step 1: Load multiple experiment datasets and build the logical transition dictionary
# -----------------------------
def load_data(file_paths):
    logical_indices_dictionary = {}
    for path in file_paths:
        data = np.load(path)
        states = data['states']
        data.close()

        experiment_data = list(states)
        # Convert each Boolean state to an integer index (1-based)
        logical_form = [
            sum((1 - state[i]) * pow(2, len(state) - i - 1) for i in range(len(state))) + 1
            for state in experiment_data
        ]

        # Store transitions: current state → next state
        for i in range(0, len(logical_form) - 1, 2):
            key, value = logical_form[i], logical_form[i + 1]
            logical_indices_dictionary.setdefault(key, []).append(value)

    return dict(sorted(logical_indices_dictionary.items()))

# File paths for all 10 experimental datasets
file_paths = [f'data_{i}.npz' for i in range(1, 13)]
logical_indices_dictionary = load_data(file_paths)

# -----------------------------
# Step 2: Construct L_indices vector (used to build transition matrix L)
# -----------------------------
L_indices = np.zeros(num_states, dtype=int)
for key, value in logical_indices_dictionary.items():
    L_indices[key - 1] = int(value[0]) 

# Build the transition matrix L
L = np.zeros((num_states, num_states))
for row in np.where(L_indices != 0)[0]:
    L[row, L_indices[row] - 1] = 1
L = L.T  

# -----------------------------
# Step 3: Generate structure matrices S_i for each Boolean variable
# -----------------------------
def generate_S_matrix(n):
    S_matrix = []
    for i in range(1, n + 1):
        repeat_1, repeat_2 = 2 ** (n - i), 2 ** (i - 1)
        row = np.tile([1] * repeat_1 + [2] * repeat_1, repeat_2)
        S_matrix.append(row)
    return np.array(S_matrix)

S_matrix = generate_S_matrix(5)

# Define delta vectors for Boolean values 0 and 1
delta_1 = np.array([[1], [0]])  # δ1 (represents Boolean 0)
delta_2 = np.array([[0], [1]])  # δ2 (represents Boolean 1)

# Build S matrices as horizontal stacks of δ vectors
S_matrices = [
    np.hstack([delta_1 if val == 1 else delta_2 for val in S_matrix[row]])
    for row in range(5)
]

# -----------------------------
# Step 4: Compute Boolean control function matrices M_i = S_i · L
# -----------------------------
M_matrices = [sp(S_row, L) for S_row in S_matrices]

# -----------------------------
# Step 5: Use permutation matrices to test regulator influence
# -----------------------------
I2 = np.eye(2)
Mn = np.array([[0, 1], [1, 0]])  # Logical NOT operator

# Permutation matrix W[m,n] for Kronecker products
def lwij(m, n):
    size = m * n
    W = np.zeros((size, size))
    for i in range(m):
        for j in range(n):
            W[i * n + j, j * m + i] = 1
    return W

# Test which genes regulate S1P (first node)
M1 = M_matrices[0]  # M for S1P
print("Testing regulatory factors for: S1P")

for i, name in enumerate(["S1P", "FLIP", "Fas", "Ceramide", "DISC", "Apoptosis"]):
    W = lwij(2, 2 ** i)
    P = sp(sp(M1, W), Mn - I2)
    is_zero = np.all(P == 0)
    print(f"{name}:", is_zero)

# -----------------------------
# Step 6: Fix some variable inputs and evaluate control output
# Example: Ceramide = 0, Apoptosis = 0, x1–x4 = 1
# -----------------------------
Mp = sp(M1, lwij(2, 16))  # Rearrangement for Ceramide (x5)
Mp = sp(Mp, delta_1)      # Ceramide = 0
Mp = sp(Mp, delta_1)      # x1 = 0
Mp = sp(Mp, delta_1)      # x2 = 0
Mp = sp(Mp, delta_1)      # x3 = 0
Mp = sp(Mp, delta_1)      # x4 = 0
Mp = sp(Mp, delta_1)      # Apoptosis = 0

print("\nFinal result for S1P when Ceramide = 0, Apoptosis = 0:")
print(Mp)
print('------------------------')
